#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include "../assembler/demi_assembler.hpp"
#include "../assembler/lexer.hpp"
#include "../assembler/parser.hpp"
#include "../assembler/assembler.hpp"

void print_bytecode(const std::vector<uint8_t>& bytecode) {
    std::cout << "Generated bytecode (" << bytecode.size() << " bytes):\n";
    for (size_t i = 0; i < bytecode.size(); ++i) {
        if (i % 16 == 0) {
            std::cout << std::setw(4) << std::setfill('0') << std::hex << i << ": ";
        }
        std::cout << std::setw(2) << std::setfill('0') << std::hex << static_cast<int>(bytecode[i]) << " ";
        if ((i + 1) % 16 == 0 || i == bytecode.size() - 1) {
            std::cout << "\n";
        }
    }
    std::cout << std::dec; // Reset to decimal
}

int main(int argc, char* argv[]) {
    std::cout << "Testing DemiEngine Assembler\n";
    std::cout << "==========================\n\n";

    std::string test_code;

    if (argc > 1) {
        // Read from file
        std::ifstream file(argv[1]);
        if (!file.is_open()) {
            std::cerr << "Error: Could not open file " << argv[1] << std::endl;
            return 1;
        }

        std::ostringstream oss;
        oss << file.rdbuf();
        test_code = oss.str();
        std::cout << "Reading assembly from file: " << argv[1] << "\n\n";
    } else {
        // Use default test code
        test_code = R"(
        ; Simple test program
        main:
            LOAD_IMM RAX, 42
            LOAD_IMM RBX, 13
            ADD RAX, RBX
            HALT
    )";
        std::cout << "Using default test code:\n\n";
    }

    std::cout << "Assembly source:\n" << test_code << "\n";

    // Step 1: Lexical analysis
    std::cout << "Step 1: Lexical Analysis\n";
    Assembler::Lexer lexer(test_code);
    auto tokens = lexer.tokenize();

    if (lexer.has_errors()) {
        std::cout << "Lexer errors:\n";
        for (const auto& error : lexer.get_errors()) {
            std::cout << "  " << error << "\n";
        }
        return 1;
    }

    std::cout << "Tokens generated: " << tokens.size() << "\n";

    // Print first few tokens for debugging
    std::cout << "First 10 tokens:\n";
    for (size_t i = 0; i < std::min(tokens.size(), size_t(10)); ++i) {
        std::cout << "  " << i << ": " << static_cast<int>(tokens[i].type) << " '" << tokens[i].text << "'\n";
    }
    std::cout << "\n";

    // Step 2: Parsing
    std::cout << "Step 2: Parsing\n";
    Assembler::Parser parser(tokens);
    auto ast = parser.parse();

    if (parser.has_errors()) {
        std::cout << "Parser errors:\n";
        for (const auto& error : parser.get_errors()) {
            std::cout << "  " << error << "\n";
        }
        return 1;
    }

    std::cout << "AST statements: " << ast->statements.size() << "\n\n";

    // Step 3: Code generation
    std::cout << "Step 3: Code Generation\n";
    Assembler::AssemblerEngine assembler;
    auto bytecode = assembler.assemble(*ast);

    if (assembler.has_errors()) {
        std::cout << "Assembly errors:\n";
        for (const auto& error : assembler.get_errors()) {
            std::cout << "  " << error << "\n";
        }
        return 1;
    }

    print_bytecode(bytecode);

    // Show symbol table
    const auto& symbols = assembler.get_symbols();
    if (!symbols.empty()) {
        std::cout << "\nSymbol table:\n";
        for (const auto& [name, symbol] : symbols) {
            std::cout << "  " << name << " = 0x" << std::hex << symbol.address << std::dec << "\n";
        }
    }

    std::cout << "\nTest completed successfully!\n";
    return 0;
}